import fs from "fs-extra";
import { join, extname, basename } from "node:path/posix";

import { normalizedGlob, tryReadDir } from "../tools/fs.mjs";

const scriptsTemplate = `
/**
 * Generated by Babylon.js Editor
 */

import { loadScene, scriptsDictionary, scriptAssetsCache, _applyScriptsForObject, _removeRegisteredScriptInstance, _preloadScriptsAssets } from "babylonjs-editor-tools";
{{imports}}

export const scriptsMap = {
    {{exports}}
};

export { loadScene, scriptsDictionary, scriptAssetsCache, _applyScriptsForObject, _removeRegisteredScriptInstance, _preloadScriptsAssets };
`;

const createUniqueIdentifier = (filepath: string): string => {
	const nameWithoutExt = filepath.replace(extname(filepath), "");
	return nameWithoutExt
		.replace(/[^a-zA-Z0-9_]/g, "_")
		.replace(/^[0-9]/, "_$&")
		.replace(/\//g, "_");
};

interface ICollectedMetadata {
	entityName: string;
	metadata: any;
}

export async function createScriptsFile(projectDir: string): Promise<void> {
	const sceneFolders = await normalizedGlob(join(projectDir, "assets/**/*.scene"), {
		nodir: false,
	});

	const scriptsMap: Record<string, string> = {};

	const availableMetadata: ICollectedMetadata[] = [];

	// Check on all scenes in assets
	await Promise.all(
		sceneFolders.map(async (file) => {
			try {
				const config = await fs.readJSON(join(file, "config.json"));
				if (config.metadata) {
					availableMetadata.push({
						entityName: basename(file),
						metadata: config.metadata,
					});
				}
			} catch (e) {
				// Catch silently.
			}

			const [nodesFiles, meshesFiles, lightsFiles, cameraFiles, spriteManagerfiles, spriteMapFiles] = await Promise.all([
				tryReadDir(join(file, "nodes")),
				tryReadDir(join(file, "meshes")),
				tryReadDir(join(file, "lights")),
				tryReadDir(join(file, "cameras")),
				tryReadDir(join(file, "sprite-managers")),
				tryReadDir(join(file, "sprite-maps")),
			]);

			await Promise.all(
				[
					...nodesFiles.map((file) => join("nodes", file)),
					...meshesFiles.map((file) => join("meshes", file)),
					...lightsFiles.map((file) => join("lights", file)),
					...cameraFiles.map((file) => join("cameras", file)),
					...spriteMapFiles.map((file) => join("sprite-maps", file)),
					...spriteManagerfiles.map((file) => join("sprite-managers", file)),
				].map(async (f) => {
					const data = await fs.readJSON(join(file, f), "utf-8");
					if (data.metadata) {
						availableMetadata.push({
							metadata: data.metadata,
							entityName: data.name ?? data.meshes?.[0]?.name,
						});
					}
				})
			);

			await Promise.all(
				spriteManagerfiles
					.map((file) => join("sprite-managers", file))
					.map(async (f) => {
						const data = await fs.readJSON(join(file, f), "utf-8");
						data.spriteManager?.sprites.forEach((sprite) => {
							if (sprite.metadata) {
								availableMetadata.push({
									metadata: sprite.metadata,
									entityName: sprite.name,
								});
							}
						});
					})
			);
		})
	);

	const promises: Promise<void>[] = [];
	availableMetadata.forEach((configuration) => {
		configuration.metadata.scripts?.forEach((script) => {
			promises.push(
				new Promise<void>(async (resolve) => {
					const path = join(projectDir, "src", script.key);
					if (!(await fs.pathExists(path))) {
						return resolve();
					}

					const extension = extname(script.key).toLowerCase();
					scriptsMap[script.key] = `@/${script.key.replace(extension, "")}`;

					resolve();
				})
			);
		});
	});

	await Promise.all(promises);

	const importStatements: string[] = [];
	Object.keys(scriptsMap).forEach((key) => {
		const scriptName = createUniqueIdentifier(key);
		importStatements.push(`import * as ${scriptName} from "./${key.replace(extname(key), "")}";`);
	});
	const importsContent = importStatements.join("\n");

	const exportsContent = Object.keys(scriptsMap)
		.map((key) => {
			const scriptName = createUniqueIdentifier(key);
			return `"${key}": ${scriptName}`;
		})
		.join(",\n\t");

	const finalContent = scriptsTemplate.replace("{{imports}}", importsContent).replace("{{exports}}", exportsContent);

	await fs.writeFile(join(projectDir, "src/scripts.ts"), finalContent, {
		encoding: "utf-8",
	});
}
