import { join, dirname, extname } from "path/posix";
import { pathExists, readJSON, readdir, writeFile } from "fs-extra";

import { normalizedGlob } from "../../tools/fs";

import { Editor } from "../../editor/main";

const commonJsModuleTemplate = `
/**
 * Generated by Babylon.js Editor
 */

import { loadScene } from "babylonjs-editor-tools";

export const scriptsMap = {
    {{exports}}
};

export { loadScene };
`;

const es6ModuleTemplate = `
/**
 * Generated by Babylon.js Editor
 */

{{imports}}

export const scriptsMap = {
    {{exports}}
};
`;

export async function handleExportScripts(editor: Editor): Promise<void> {
	if (!editor.state.projectPath) {
		return;
	}

	const projectPath = dirname(editor.state.projectPath);
	const projectTemplate = editor.state.projectTemplate ?? "nextjs";

	const sceneFolders = await normalizedGlob(join(projectPath, "assets/**/*.scene"), {
		nodir: false,
	});

	const scriptsMap: Record<string, string> = {};

	const availableMetadata: any[] = [];

	// Check on all scenes in assets
	await Promise.all(sceneFolders.map(async (file) => {
		try {
			const config = await readJSON(join(file, "config.json"));
			if (config.metadata) {
				availableMetadata.push(config.metadata);
			}
		} catch (e) {
			// Catch silently.
		}

		const [nodesFiles, meshesFiles, lightsFiles, cameraFiles] = await Promise.all([
			readdir(join(file, "nodes")),
			readdir(join(file, "meshes")),
			readdir(join(file, "lights")),
			readdir(join(file, "cameras")),
		]);

		await Promise.all([
			...nodesFiles.map((file) => join("nodes", file)),
			...meshesFiles.map((file) => join("meshes", file)),
			...lightsFiles.map((file) => join("lights", file)),
			...cameraFiles.map((file) => join("cameras", file)),
		].map(async (f) => {
			const data = await readJSON(join(file, f), "utf-8");
			if (data.metadata) {
				availableMetadata.push(data.metadata);
			}
		}));
	}));

	// Check on all nodes in current scene
	const entities = [
		...editor.layout.preview.scene.meshes,
		...editor.layout.preview.scene.lights,
		...editor.layout.preview.scene.cameras,
		...editor.layout.preview.scene.transformNodes,
		...editor.layout.preview.scene.particleSystems,
	] as { metadata?: any; }[];

	entities.forEach((entity) => {
		if (entity.metadata) {
			availableMetadata.push(entity.metadata);
		}
	});

	const promises: Promise<void>[] = [];
	availableMetadata.forEach((metadata) => {
		metadata.scripts?.forEach((script) => {
			promises.push(new Promise<void>(async (resolve) => {
				const path = join(projectPath, "src", script.key);
				if (!await pathExists(path)) {
					return resolve();
				}

				const extension = extname(script.key).toLowerCase();
				scriptsMap[script.key] = `@/${script.key.replace(extension, "")}`;

				resolve();
			}));
		});
	});


	await Promise.all(promises);

	let template: string;
	let exportsContent: string;
	let importsContent: string = "";

	switch (projectTemplate) {
		case "vanillajs":
		case "solidjs":
			template = es6ModuleTemplate;
			const importStatements: string[] = [];
			Object.keys(scriptsMap).forEach((key) => {
				const scriptName = key.replace(extname(key), "").split("/").pop();
				importStatements.push(`import ${scriptName} from "./${key.replace(extname(key), "")}";`);
			});
			importsContent = importStatements.join("\n");
			
			exportsContent = Object.keys(scriptsMap).map((key) => {
				const scriptName = key.replace(extname(key), "").split("/").pop();
				return `"${key}": {\n\t\tdefault: ${scriptName}\n\t}`;
			}).join(",\n\t");
			break;
			
		case "nextjs":
		default:
			template = commonJsModuleTemplate;
			exportsContent = Object.keys(scriptsMap).map((key) => `"${key}": require("${scriptsMap[key]}")`).join(",\n\t");
			break;
	}

	const finalContent = template
		.replace("{{imports}}", importsContent)
		.replace("{{exports}}", exportsContent);

	await writeFile(
		join(projectPath, "src/scripts.ts"),
		finalContent,
		{
			encoding: "utf-8",
		});
}
