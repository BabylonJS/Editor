import { join, dirname, extname, basename } from "path/posix";
import { pathExists, readJSON, readdir, writeFile } from "fs-extra";

import { normalizedGlob } from "../../tools/fs";

import { Editor } from "../../editor/main";

const scriptsTemplate = `
/**
 * Generated by Babylon.js Editor
 */

import { loadScene, scriptsDictionary, scriptAssetsCache, _applyScriptsForObject, _removeRegisteredScriptInstance, _preloadScriptsAssets } from "babylonjs-editor-tools";
{{imports}}

export const scriptsMap = {
    {{exports}}
};

export { loadScene, scriptsDictionary, scriptAssetsCache, _applyScriptsForObject, _removeRegisteredScriptInstance, _preloadScriptsAssets };
`;

const createUniqueIdentifier = (filepath: string): string => {
	const nameWithoutExt = filepath.replace(extname(filepath), "");
	return nameWithoutExt
		.replace(/[^a-zA-Z0-9_]/g, "_")
		.replace(/^[0-9]/, "_$&")
		.replace(/\//g, "_");
};

interface ICollectedMetadata {
	entityName: string;
	metadata: any;
}

export async function handleExportScripts(editor: Editor): Promise<void> {
	if (!editor.state.projectPath) {
		return;
	}

	const projectPath = dirname(editor.state.projectPath);

	const sceneFolders = await normalizedGlob(join(projectPath, "assets/**/*.scene"), {
		nodir: false,
	});

	const scriptsMap: Record<string, string> = {};

	const availableMetadata: ICollectedMetadata[] = [];

	// Check on all scenes in assets
	await Promise.all(
		sceneFolders.map(async (file) => {
			try {
				const config = await readJSON(join(file, "config.json"));
				if (config.metadata) {
					availableMetadata.push({
						entityName: basename(file),
						metadata: config.metadata,
					});
				}
			} catch (e) {
				// Catch silently.
			}

			const [nodesFiles, meshesFiles, lightsFiles, cameraFiles] = await Promise.all([
				readdir(join(file, "nodes")),
				readdir(join(file, "meshes")),
				readdir(join(file, "lights")),
				readdir(join(file, "cameras")),
			]);

			await Promise.all(
				[
					...nodesFiles.map((file) => join("nodes", file)),
					...meshesFiles.map((file) => join("meshes", file)),
					...lightsFiles.map((file) => join("lights", file)),
					...cameraFiles.map((file) => join("cameras", file)),
				].map(async (f) => {
					const data = await readJSON(join(file, f), "utf-8");
					if (data.metadata) {
						availableMetadata.push({
							metadata: data.metadata,
							entityName: data.name ?? data.meshes?.[0]?.name,
						});
					}
				})
			);
		})
	);

	// Check on all nodes in current scene
	const entities = [
		...editor.layout.preview.scene.meshes,
		...editor.layout.preview.scene.lights,
		...editor.layout.preview.scene.cameras,
		...editor.layout.preview.scene.transformNodes,
		...editor.layout.preview.scene.particleSystems,
	] as { name: string; metadata?: any }[];

	entities.forEach((entity) => {
		if (entity.metadata) {
			availableMetadata.push({
				entityName: entity.name,
				metadata: entity.metadata,
			});
		}
	});

	const promises: Promise<void>[] = [];
	availableMetadata.forEach((configuration) => {
		configuration.metadata.scripts?.forEach((script) => {
			promises.push(
				new Promise<void>(async (resolve) => {
					const path = join(projectPath, "src", script.key);
					if (!(await pathExists(path))) {
						editor.layout.selectTab("console");
						editor.layout.console.error(
							`Processing "${configuration.entityName}". Script '${script.key}' doesn't exist or was moved in the project. Please fix the issue before generating scene.`
						);
						return resolve();
					}

					const extension = extname(script.key).toLowerCase();
					scriptsMap[script.key] = `@/${script.key.replace(extension, "")}`;

					resolve();
				})
			);
		});
	});

	await Promise.all(promises);

	const importStatements: string[] = [];
	Object.keys(scriptsMap).forEach((key) => {
		const scriptName = createUniqueIdentifier(key);
		importStatements.push(`import * as ${scriptName} from "./${key.replace(extname(key), "")}";`);
	});
	const importsContent = importStatements.join("\n");

	const exportsContent = Object.keys(scriptsMap)
		.map((key) => {
			const scriptName = createUniqueIdentifier(key);
			return `"${key}": ${scriptName}`;
		})
		.join(",\n\t");

	const finalContent = scriptsTemplate.replace("{{imports}}", importsContent).replace("{{exports}}", exportsContent);

	await writeFile(join(projectPath, "src/scripts.ts"), finalContent, {
		encoding: "utf-8",
	});
}
