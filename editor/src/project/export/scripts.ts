import { join, dirname, extname } from "path/posix";
import { pathExists, readJSON, readdir, writeFile } from "fs-extra";

import { normalizedGlob } from "../../tools/fs";

import { Editor } from "../../editor/main";

const scriptsTemplate = `
/**
 * Generated by Babylon.js Editor
 */

import { loadScene } from "babylonjs-editor-tools";
{{imports}}

export const scriptsMap = {
    {{exports}}
};

export { loadScene };
`;

const createUniqueIdentifier = (filepath: string): string => {
	const nameWithoutExt = filepath.replace(extname(filepath), "");
	return nameWithoutExt
		.replace(/[^a-zA-Z0-9_]/g, "_")
		.replace(/^[0-9]/, "_$&")
		.replace(/\//g, "_");
};


export async function handleExportScripts(editor: Editor): Promise<void> {
	if (!editor.state.projectPath) {
		return;
	}

	const projectPath = dirname(editor.state.projectPath);

	const sceneFolders = await normalizedGlob(join(projectPath, "assets/**/*.scene"), {
		nodir: false,
	});

	const scriptsMap: Record<string, string> = {};

	const availableMetadata: any[] = [];

	// Check on all scenes in assets
	await Promise.all(sceneFolders.map(async (file) => {
		try {
			const config = await readJSON(join(file, "config.json"));
			if (config.metadata) {
				availableMetadata.push(config.metadata);
			}
		} catch (e) {
			// Catch silently.
		}

		const [nodesFiles, meshesFiles, lightsFiles, cameraFiles] = await Promise.all([
			readdir(join(file, "nodes")),
			readdir(join(file, "meshes")),
			readdir(join(file, "lights")),
			readdir(join(file, "cameras")),
		]);

		await Promise.all([
			...nodesFiles.map((file) => join("nodes", file)),
			...meshesFiles.map((file) => join("meshes", file)),
			...lightsFiles.map((file) => join("lights", file)),
			...cameraFiles.map((file) => join("cameras", file)),
		].map(async (f) => {
			const data = await readJSON(join(file, f), "utf-8");
			if (data.metadata) {
				availableMetadata.push(data.metadata);
			}
		}));
	}));

	// Check on all nodes in current scene
	const entities = [
		...editor.layout.preview.scene.meshes,
		...editor.layout.preview.scene.lights,
		...editor.layout.preview.scene.cameras,
		...editor.layout.preview.scene.transformNodes,
		...editor.layout.preview.scene.particleSystems,
	] as { metadata?: any; }[];

	entities.forEach((entity) => {
		if (entity.metadata) {
			availableMetadata.push(entity.metadata);
		}
	});

	const promises: Promise<void>[] = [];
	availableMetadata.forEach((metadata) => {
		metadata.scripts?.forEach((script) => {
			promises.push(new Promise<void>(async (resolve) => {
				const path = join(projectPath, "src", script.key);
				if (!await pathExists(path)) {
					return resolve();
				}

				const extension = extname(script.key).toLowerCase();
				scriptsMap[script.key] = `@/${script.key.replace(extension, "")}`;

				resolve();
			}));
		});
	});


	await Promise.all(promises);

	const importStatements: string[] = [];
	Object.keys(scriptsMap).forEach((key) => {
		const scriptName = createUniqueIdentifier(key);
		importStatements.push(`import * as ${scriptName} from "./${key.replace(extname(key), "")}";`);
	});
	const importsContent = importStatements.join("\n");

	const exportsContent = Object.keys(scriptsMap).map((key) => {
		const scriptName = createUniqueIdentifier(key);
		return `"${key}": ${scriptName}`;
	}).join(",\n\t");

	const finalContent = scriptsTemplate
		.replace("{{imports}}", importsContent)
		.replace("{{exports}}", exportsContent);

	await writeFile(
		join(projectPath, "src/scripts.ts"),
		finalContent,
		{
			encoding: "utf-8",
		});
}
