// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../babylonjs
//   ../../dat-gui
//   ../../golden-layout
//   ../../babylonjs-editor-code-editor
//   ../../babylonjs-gui
//   ../../babylonjs-materials

declare module 'babylonjs-editor' {
    import Editor from 'babylonjs-editor/editor/editor';
    import Tools from 'babylonjs-editor/editor/tools/tools';
    import Request from 'babylonjs-editor/editor/tools/request';
    import UndoRedo from 'babylonjs-editor/editor/tools/undo-redo';
    import ThemeSwitcher, { ThemeType } from 'babylonjs-editor/editor/tools/theme';
    import GraphicsTools from 'babylonjs-editor/editor/tools/graphics-tools';
    import Layout from 'babylonjs-editor/editor/gui/layout';
    import Toolbar from 'babylonjs-editor/editor/gui/toolbar';
    import List from 'babylonjs-editor/editor/gui/list';
    import Grid, { GridRow } from 'babylonjs-editor/editor/gui/grid';
    import Picker from 'babylonjs-editor/editor/gui/picker';
    import Graph, { GraphNode } from 'babylonjs-editor/editor/gui/graph';
    import Window from 'babylonjs-editor/editor/gui/window';
    import CodeEditor from 'babylonjs-editor/editor/gui/code';
    import Form from 'babylonjs-editor/editor/gui/form';
    import Edition from 'babylonjs-editor/editor/gui/edition';
    import Tree, { TreeContextMenuItem, TreeNode } from 'babylonjs-editor/editor/gui/tree';
    import Dialog from 'babylonjs-editor/editor/gui/dialog';
    import ContextMenu, { ContextMenuItem } from 'babylonjs-editor/editor/gui/context-menu';
    import ResizableLayout, { ComponentConfig, ItemConfigType } from 'babylonjs-editor/editor/gui/resizable-layout';
    import AbstractEditionTool from 'babylonjs-editor/editor/edition-tools/edition-tool';
    import { IStringDictionary, IDisposable, INumberDictionary } from 'babylonjs-editor/editor/typings/typings';
    import { EditorPlugin } from 'babylonjs-editor/editor/typings/plugin';
    import { ProjectRoot } from 'babylonjs-editor/editor/typings/project';
    import CodeProjectEditorFactory from 'babylonjs-editor/editor/project/project-code-editor';
    import SceneManager from 'babylonjs-editor/editor/scene/scene-manager';
    import SceneFactory from 'babylonjs-editor/editor/scene/scene-factory';
    import ScenePreview from 'babylonjs-editor/editor/scene/scene-preview';
    import ScenePicker from 'babylonjs-editor/editor/scene/scene-picker';
    import PrefabAssetComponent from 'babylonjs-editor/editor/prefabs/asset-component';
    import { Prefab, PrefabNodeType } from 'babylonjs-editor/editor/prefabs/prefab';
    import ParticlesCreatorExtension, { ParticlesCreatorMetadata } from 'babylonjs-editor/editor/particles/asset-component';
    import Storage from 'babylonjs-editor/editor/storage/storage';
    import VSCodeSocket from 'babylonjs-editor/editor/vscode/vscode-socket';
    export default Editor;
    export { Editor, Tools, Request, UndoRedo, ThemeSwitcher, ThemeType, GraphicsTools, IStringDictionary, INumberDictionary, IDisposable, EditorPlugin, Layout, Toolbar, List, Grid, GridRow, Picker, Graph, GraphNode, Window, CodeEditor, Form, Edition, Tree, TreeContextMenuItem, TreeNode, Dialog, ContextMenu, ContextMenuItem, ResizableLayout, ComponentConfig, ItemConfigType, AbstractEditionTool, ProjectRoot, CodeProjectEditorFactory, SceneManager, SceneFactory, ScenePreview, ScenePicker, PrefabAssetComponent, Prefab, PrefabNodeType, ParticlesCreatorExtension, ParticlesCreatorMetadata, Storage, VSCodeSocket };
}

declare module 'babylonjs-editor/editor/editor' {
    import { Scene, FreeCamera, Camera, FilesInput, ArcRotateCamera } from 'babylonjs';
    import { IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    import { IEditorPlugin } from 'babylonjs-editor/editor/typings/plugin';
    import Core, { IUpdatable } from 'babylonjs-editor/editor/core';
    import Layout from 'babylonjs-editor/editor/gui/layout';
    import ResizableLayout from 'babylonjs-editor/editor/gui/resizable-layout';
    import EditorToolbar from 'babylonjs-editor/editor/components/toolbar';
    import EditorGraph from 'babylonjs-editor/editor/components/graph';
    import EditorPreview from 'babylonjs-editor/editor/components/preview';
    import EditorInspector from 'babylonjs-editor/editor/components/inspector';
    import EditorEditPanel from 'babylonjs-editor/editor/components/edit-panel';
    import EditorStats from 'babylonjs-editor/editor/components/stats';
    import EditorAssets from 'babylonjs-editor/editor/components/assets';
    import EditorFiles from 'babylonjs-editor/editor/components/files';
    import ScenePicker from 'babylonjs-editor/editor/scene/scene-picker';
    import SceneIcons from 'babylonjs-editor/editor/scene/scene-icons';
    export default class Editor implements IUpdatable {
            core: Core;
            camera: FreeCamera | ArcRotateCamera;
            playCamera: Camera;
            layout: Layout;
            resizableLayout: ResizableLayout;
            toolbar: EditorToolbar;
            graph: EditorGraph;
            preview: EditorPreview;
            inspector: EditorInspector;
            editPanel: EditorEditPanel;
            stats: EditorStats;
            assets: EditorAssets;
            files: EditorFiles;
            plugins: IStringDictionary<IEditorPlugin>;
            scenePicker: ScenePicker;
            sceneIcons: SceneIcons;
            filesInput: FilesInput;
            sceneFile: File;
            guiFiles: File[];
            projectFile: File;
            projectFileName: string;
            _showReloadDialog: boolean;
            static LayoutVersion: string;
            static EditorVersion: string;
            /**
                * Constructor
                * @param scene: a scene to edit. If undefined, a default scene will be created
                */
            constructor(scene?: Scene);
            /**
                * Runs the editor and Babylon.js engine
                */
            run(): void;
            /**
             * Resizes elements
             */
            resize(): Promise<void>;
            /**
                * On after render the scene
                */
            onPostUpdate(): void;
            /**
                * Returns the extension instance identified by the given name
                * @param name the name of the extension
                */
            getExtension<T>(name: string): T;
            /**
                * Adds an "edit panel" plugin
                * @param url the URL of the plugin
                * @param restart: if to restart the plugin
                * @param name: the name of the plugin to show
                * @param params: the params to give to the plugin's constructor
                */
            addEditPanelPlugin(url: string, restart?: boolean, name?: string, ...params: any[]): Promise<IEditorPlugin>;
            /**
                * Removes the given plugin
                * @param plugin: the plugin to remove
                */
            removePlugin(plugin: IEditorPlugin, removePanel?: boolean): Promise<void>;
            /**
                * Restarts the plugins already loaded
                */
            restartPlugins(removePanels?: boolean): Promise<void>;
            /**
                * Notifies a message at the bottom of the editor
                * @param message the message to show in notification
                * @param spinner if the notification should have a spinner
                * @param timeout time in ms to wait before hidding the message
                */
            notifyMessage(message: string, spinner?: boolean, timeout?: number): void;
            /**
                * Checks if the user opened a file
                * @param fullLoad sets if the loader should load newly added files in the scene folder
                */
            checkOpenedFile(): Promise<void>;
            /**
                * Returns the project file looking from the files input store
                */
            getProjectFileFromFilesInputStore(): File;
            /**
                * Creates the scene picker
                */
            createScenePicker(): void;
            /**
                * Creates the default scene
                * @param showNewSceneDialog if to show a dialog to confirm creating default scene
                * @param emptyScene sets wether or not the default scene would be empty or not
                */
            createDefaultScene(showNewSceneDialog?: boolean, emptyScene?: boolean): Promise<void>;
            /**
                * Creates the editor camera
                */
            createEditorCamera(type?: 'arc' | 'free' | any): Camera;
            /**
                * Resets the editor's state
                */
            resetEditorState(): Promise<void>;
    }
}

declare module 'babylonjs-editor/editor/tools/tools' {
    import { Scene, BaseTexture } from 'babylonjs';
    import { IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    export default class Tools {
            static PendingFilesToLoad: number;
            static IsStandalone: boolean;
            static Version: string;
            static Epsilon: number;
            /**
                * Creates a div element
                * @param style: the div's style
                */
            static CreateElement<T extends HTMLElement>(type: string, id: string, style?: IStringDictionary<string>): T;
            /**
                * Returns if the given element is a child (recursively) of the given parent
                * @param element the element being possibily a child of the given parent
                * @param parent the parent to check
                */
            static IsElementChildOf(element: HTMLElement, parent: HTMLElement): boolean;
            /**
                * Returns if the focused element in the DOM is an input
                */
            static IsFocusingInputElement(): boolean;
            /**
             * Returns the constructor name of the given object
             * @param obj the object
             */
            static GetConstructorName(obj: any): string;
            /**
                * Returns if the browser is running in Electron
                */
            static IsElectron(): boolean;
            /**
             * Returns the file type for the given extension
             */
            static GetFileType(extension: string): string;
            /**
                * Creates a window popup
                * @param url the URL of the popup
                * @param name: the name of the popup
                * @param width the width of the popup
                * @param height the height of the popup
                */
            static OpenPopup(url: string, name: string, width: number, height: number): Window;
            /**
                * Set window's title
                * @param title the title of the window
                */
            static SetWindowTitle(title: string): void;
            /**
             * Returns the file extension
             * @param filename: the file's name
             */
            static GetFileExtension(filename: string): string;
            /**
             * Returns the filename without extension
             * @param filename: the filename (path)
             * @param withPath: if the return value should contain all path
             */
            static GetFilenameWithoutExtension(filename: string, withPath?: boolean): string;
            /**
                * Returns the filename
                * @param filename: the complete filename with path
                */
            static GetFilename(filename: string): string;
            /**
                * Returns the first texture found wich has the given name
                * @param scene the scene containing the textures
                * @param name the name of the texture to find
                */
            static GetTextureByName(scene: Scene, name: string): BaseTexture;
            /**
                * Creates an open file dialog
                * @param callback called once the user selects files
                */
            static OpenFileDialog(callback?: (files: File[]) => void): Promise<File[]>;
            /**
                * Returns the base url of the window
                */
            static GetBaseURL(): string;
            /**
                * Sorts the given string array alphabetically
                * @param arr: the array to sort
                * @param property: the property to take
                */
            static SortAlphabetically(arr: any[], property?: string): void;
            /**
                * Creates a new File (blob today to fix Edge compatibility)
                * @param buffer the file's buffer
                * @param filename the file's name
                */
            static CreateFile(buffer: Uint8Array, filename: string): File;
            /**
                * Loads a file using HTTP request
                * @param url the url of the file
                * @param arrayBuffer if should load file as arraybuffer
                */
            static LoadFile<T extends string | ArrayBuffer>(url: string, arrayBuffer?: boolean, onProgress?: (data?: any) => void): Promise<T>;
            /**
                * Loads a file and creates a new File added to the FilesToLoad
                * @param url: the URLof the file
                */
            static CreateFileFromURL(url: string): Promise<File>;
            /**
                * Loads a file and creates a new File
                * @param url the URLof the file
                */
            static GetFile(url: string): Promise<File>;
            /**
                * Returns the given file path (for electron)
                * @param file the file to get its path
                */
            static GetFilePath(file: File): string;
            /**
                * Converts a string to an UInt8Array
                * @param str: the string to convert
                */
            static ConvertStringToUInt8Array(str: string): Uint8Array;
            /**
                * Copy the values of all of the enumerable own properties from one or more source objects to a
                * target object. Returns the target object.
                * @param target The target object to copy to.
                * @param sources One or more source objects from which to copy properties
                */
            static Assign<T>(target: Object, ...sources: Object[]): T;
            /**
                * Deep clones the given object. Take care of cycling objects!
                * @param data the data of the object to clone
                */
            static Clone<T>(data: T): T;
            /**
                * Reads the given file
                * @param file the file to read
                * @param arrayBuffer if should read as array buffer
                */
            static ReadFile<T extends string | ArrayBuffer>(file: File, arrayBuffer: boolean): Promise<T>;
            /**
                * Reads a file as base 64
                * @param file the file to read
                */
            static ReadFileAsBase64(file: File): Promise<string>;
            /**
                * Reads a file as text
                * @param file the file to read
                */
            static ReadFileAsText(file: File): Promise<string>;
            /**
                * Reads a file as array buffer
                * @param file the file to read
                */
            static ReadFileAsArrayBuffer(file: File): Promise<ArrayBuffer>;
            /**
                * Imports a new script returning its exported object
                * @param url the URL / NAME of the script
                */
            static ImportScript<T>(url: string): Promise<T>;
            /**
                * According to the navigator, returns if the file API
                * is supported
                */
            static isFileApiSupported(showAlert?: boolean): boolean;
    }
}

declare module 'babylonjs-editor/editor/tools/request' {
    import { IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    export default class Request {
            /**
                * Sends a GET request
                * @param url: url of the request
                * @param headers: the request headers
                */
            static Get<T>(url: string, headers?: IStringDictionary<any>): Promise<T>;
            /**
                * Sends a PUT request
                * @param url the url of the request
                * @param content the content to put
                * @param headers the request headers
                */
            static Put<T>(url: string, content: any, headers?: IStringDictionary<any>): Promise<T>;
            /**
                * Sends a POST request
                * @param url the url of the request
                * @param content the content to post
                * @param headers the request headers
                */
            static Post<T>(url: string, content: any, headers?: IStringDictionary<any>): Promise<T>;
    }
}

declare module 'babylonjs-editor/editor/tools/undo-redo' {
    export interface StackElement {
            scope?: string;
            baseObject?: any;
            property?: string;
            to?: any;
            from?: any;
            object?: any;
            fn?: (type?: 'from' | 'to') => void;
            undo?: () => void;
            redo?: () => void;
    }
    export default class UndoRedo {
            static Stack: StackElement[];
            static CurrentIndex: number;
            static StackSize: number;
            static onUndo: (element: StackElement) => void;
            static onRedo: (element: StackElement) => void;
            /**
                * Pushes a new element in the stack
                * @param element the element to push in the stack
                */
            static Push(element: StackElement): void;
            /**
                * Pops an element from the undo/redo stack
                */
            static Pop(): void;
            /**
                * Clears the given scope. For example when an extension has been closed
                * @param scope the scope name
                */
            static ClearScope(scope: string): void;
            /**
                * Clears the undo / redo stack
                */
            static Clear(): void;
            /**
                * Undo an action
                */
            static Undo(): StackElement;
            /**
                * Redo an action
                */
            static Redo(): StackElement;
    }
}

declare module 'babylonjs-editor/editor/tools/theme' {
    export type ThemeType = 'Light' | 'Dark';
    export default class ThemeSwitcher {
            static LightThemeUrls: string[];
            static DarkThemeUrls: string[];
            /**
                * Returns the theme's name
                */
            static ThemeName: ThemeType;
            /**
                * Applies the theme dynamically
                * @param url the url of the theme
                */
            static Apply(urls: string[]): Promise<void>;
    }
}

declare module 'babylonjs-editor/editor/tools/graphics-tools' {
    import { BaseTexture } from 'babylonjs';
    export default class GraphicsTools {
            /**
                * Configures the given texture to retrieve its pixels and create a new file (blob)
                * @param tex the texture to transform to a blob
                */
            static TextureToFile(tex: BaseTexture): Promise<Blob>;
            /**
                * Converts the given canvas data to blob
                * @param canvas the canvas to take its data and convert to a blob
                */
            static CanvasToBlob(canvas: HTMLCanvasElement): Promise<Blob>;
    }
}

declare module 'babylonjs-editor/editor/gui/layout' {
    export default class Layout {
            element: W2UI.W2Layout;
            name: string;
            panels: W2UI.W2Panel[];
            /**
                * Constructor
                * @param name the layout name
                */
            constructor(name: string);
            /**
                * Returns the size of the given panel
                * @param type the panel type (left, top, etc.)
                */
            getPanelSize(type: string): {
                    width: number;
                    height: number;
            };
            /**
                * Sets the panel size
                * @param type the panel type (left, top, etc.)
                * @param size the new panel size
                */
            setPanelSize(type: string, size: number): void;
            /**
                * Hides the given panel
                * @param type the panel type (left, top, etc.)
                */
            hidePanel(type: string): void;
            /**
                * Shows the given panel
                * @param type the panel type (left, top, etc.)
                */
            showPanel(type: string): void;
            /**
                * Locks the given panel type
                * @param type the panel type
                * @param message the message to show
                * @param showSpinner if to show a spinner
                */
            lockPanel(type: string, message?: string, showSpinner?: boolean): void;
            /**
                * Unlocks the given panel
                * @param type the panel type
                */
            unlockPanel(type: string): void;
            /**
                * Returns the panel from the given type
                * @param type the panel type
                */
            getPanelFromType(type: string): W2UI.W2Panel;
            /**
                * Builds the layout
                * @param parentId the parent id
                */
            build(parentId: string): void;
    }
}

declare module 'babylonjs-editor/editor/gui/toolbar' {
    export interface W2Item extends W2UI.W2Item {
            html?: string;
            selected?: string[];
            hidden?: boolean;
    }
    export default class Toolbar {
            name: string;
            items: W2Item[];
            right: string;
            helpUrl: string;
            element: W2UI.W2Toolbar;
            onClick: (target: string) => void;
            /**
                * Constructor
                * @param name the graph name
                */
            constructor(name: string);
            /**
                * Returns if the given item is checked
                * @param id the id of the element (menu, item, etc.)
                */
            isChecked(id: string, justClicked?: boolean): boolean;
            /**
                * Sets an item checked or unchecked
                * @param id the id of the item
                * @param checked if the item is checked or not
                */
            setChecked(id: string, checked: boolean): void;
            /**
                * Sets an item enabled or disabled
                * @param id the id of the item
                * @param enabled if the item is enabled or not
                */
            enable(id: string, enabled: boolean): void;
            /**
                * Updates the given item
                * @param id the id of the item to update
                * @param data the new item
                */
            updateItem(id: string, data: W2Item): void;
            /**
                * Notifies the given message on the right
                * @param message the message to notify
                */
            notifyMessage(message: string): void;
            /**
                * Builds the graph
                * @param parentId the parent id
                */
            build(parentId: string): void;
    }
}

declare module 'babylonjs-editor/editor/gui/list' {
    export default class List {
            name: string;
            element: JQuery;
            input: JQuery;
            items: string[];
            onChange: (selected: string) => void;
            /**
                * Constructor
                * @param name the name of the list
                */
            constructor(name: any);
            /**
                * Sets the new items
                * @param items the new items
                */
            setItems(items: string[]): void;
            /**
                * Sets the selected item
                * @param text: the item's text
                */
            setSelected(text: string): void;
            /**
                * Returns the selected value of the list
                */
            getSelected(): string;
            /**
                * Builds the element
                * The parent HTML element
                */
            build(parent: HTMLElement, style?: string): void;
    }
}

declare module 'babylonjs-editor/editor/gui/grid' {
    export interface GridRow {
            recid?: number;
            w2ui?: {
                    style?: string;
            };
    }
    export interface GridColumn {
            field: string;
            caption: string;
            size: string;
            editable?: {
                    type: string;
            };
    }
    export interface GridOptions {
            toolbar?: boolean;
            footer?: boolean;
            toolbarEdit?: boolean;
            toolbarDelete?: boolean;
            toolbarAdd?: boolean;
            toolbarSearch?: boolean;
            toolbarColumns?: boolean;
            toolbarReload?: boolean;
            header?: string;
            columnsHeaders?: boolean;
            multiSelect?: boolean;
    }
    export interface GridContextMenuItem {
            id: number;
            text: string;
            icon?: string;
    }
    export default class Grid<T extends GridRow> {
            name: string;
            element: W2UI.W2Grid;
            options: GridOptions;
            columns: GridColumn[];
            contextMenuItems: GridContextMenuItem[];
            onClick: (selected: number[]) => void;
            onAdd: () => void;
            onDelete: (ids: number[]) => void;
            onChange: (recid: number, value: string) => void;
            onEdit: (recid: number) => void;
            onContextMenu: (id: number, recid: number) => void;
            /**
                * Constructor
                * @param name the name of the grid
                */
            constructor(name: string, options?: GridOptions);
            /**
                * Sets the options of the grid
                * @param options options of the grid
                */
            setOptions(options: GridOptions): void;
            /**
             * Adds a new row to the grid and refreshes itself
             * @param record the row record to add
             */
            addRow(record: T): void;
            /**
                * Adds a new record to the grid but does not refreshes itself
                * @param record the record to add
                */
            addRecord(record: T): void;
            /**
                * Returns the row at the given index
                * @param selected the row index
                */
            getRow(selected: number): T;
            /**
                * Sets the selected items
                * @param selected the selected items
                */
            select(selected: number[]): void;
            /**
                * Unselects all selected items
                */
            selectNone(): void;
            /**
                * Returns the selected rows
                */
            getSelected(): number[];
            /**
             * Builds the grid
             * @param parentId the parent id
             */
            build(parentId: string): void;
    }
}

declare module 'babylonjs-editor/editor/gui/picker' {
    import Window from 'babylonjs-editor/editor/gui/window';
    import Grid, { GridRow } from 'babylonjs-editor/editor/gui/grid';
    export interface PickerItem {
            name?: string | null;
            id?: string | null;
    }
    export interface Row extends GridRow {
            name: string;
    }
    export default class Picker {
            items: string[];
            selected: string[];
            window: Window;
            grid: Grid<Row>;
            title: string;
            search: boolean;
            /**
                * Constructor
                */
            constructor(title: string);
            /**
                * Adds the given items to pick
                * @param items: items to add
                */
            addItems(items: PickerItem[]): void;
            /**
                * Clears the current items
                */
            clear(): void;
            /**
                * Adds the given items as selected
                * @param items: items to add
                */
            addSelected(items: PickerItem[]): void;
            /**
                * Closes the picker
                */
            close(): void;
            /**
                * Builds the object picker
                * @param callback: called when user clicks the button "ok"
                */
            open(callback: (items: {
                    id: number;
                    name: string;
            }[], selected?: number[]) => void): Promise<void>;
            /**
                * Adds current items to the grid
                */
            refreshGrid(): void;
    }
}

declare module 'babylonjs-editor/editor/gui/graph' {
    export interface GraphNode {
            id: string;
            text: string;
            group?: boolean;
            img?: string;
            data?: any;
            count?: string;
    }
    export interface GraphMenu {
            id: string;
            text: string;
            img: string;
    }
    export default class Graph {
            name: string;
            element: W2UI.W2Sidebar;
            topContent: string;
            bottomContent: string;
            onClick: <T>(id: string, data: T) => void;
            onDbleClick: <T>(id: string, data: T) => void;
            onMenuClick: <T>(id: string, node: GraphNode) => void;
            /**
                * Constructor
                * @param name the graph name
                */
            constructor(name: string);
            /**
                * Clear the graph
                */
            clear(): void;
            /**
                * Adds the given node to the graph
                * @param node: the node to add into the graph
                * @param parent: the optional parent of the node
                */
            add(node: GraphNode, parent?: string): void;
            /**
                * Adds a context menu item to the graph when the user
                * right clicks on the node
                * @param menu the menu to add
                */
            addMenu(menu: GraphMenu): void;
            /**
                * Selects the node which has the given id
                * @param id the id of the node to select
                */
            setSelected(id: string): void;
            /**
                * Returns the selected item
                */
            getSelected(): GraphNode;
            /**
                * Builds the graph
                * @param parent the parent id
                */
            build(parent: HTMLDivElement | string): void;
    }
}

declare module 'babylonjs-editor/editor/gui/window' {
    export default class Window {
            name: string;
            element: W2UI.W2Popup;
            title: string;
            body: string;
            buttons: string[];
            width: number;
            height: number;
            showMax: boolean;
            showClose: boolean;
            onButtonClick: (id: string) => void;
            onClose: () => void;
            onMax: () => void;
            onMin: () => void;
            onToggle: () => void;
            /**
                * Constructor
                * @param name: the name of the window
                */
            constructor(name: string);
            /**
                * Closes the window
                */
            close(): void;
            /**
                * Locks the window
                * @param message: the message to draw
                */
            lock(message: string): void;
            /**
                * Unlocks the window
                */
            unlock(): void;
            /**
                * Opens the window
                */
            open(): Promise<void>;
            /**
                * Opens a window alert
                * @param message: the message to show
                * @param title: the title of the window alert
                */
            static CreateAlert(message: string, title?: string): void;
    }
}

declare module 'babylonjs-editor/editor/gui/code' {
    import { IDisposable, IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    export interface MonacoDisposable extends IDisposable {
            [index: string]: any;
    }
    export interface TypescriptDisposable extends IDisposable {
            [index: string]: any;
    }
    export interface Typings {
            name: string;
            id: string;
            content: string;
    }
    export default class CodeEditor {
            editor: MonacoDisposable;
            onChange: (value: string) => void;
            static ExternalLibraries: string;
            static ExtraLibs: {
                    lib: MonacoDisposable;
                    caller: Window;
            }[];
            static CustomLibs: IStringDictionary<MonacoDisposable>;
            static Instances: MonacoDisposable[];
            static Libs: string[];
            /**
                * Remove extra lib from the registered callers
                * @param caller the caller reference (Window)
                */
            static RemoveExtraLib(caller: Window): void;
            /**
                * Returns if at least one code editor is focused
                */
            static HasOneFocused(): boolean;
            /**
                * Constructor
                */
            constructor(language?: string, value?: string);
            /**
                * Returns the editor's value
                */
            getValue(): string;
            /**
                * Sets the value of the editor
                * @param value the value to set
                */
            setValue(value: string): void;
            /**
                * Focus the editor
                */
            focus(): void;
            /**
                * Disposes the editor
                */
            dispose(): void;
            /**
                * Builds the code editor
                * @param parentId the parent id of the editor
                */
            build(parentId: string | HTMLElement, caller?: Window): Promise<void>;
            /**
                * Transpiles the given TS source to JS source
                * @param source the source to transpile
                */
            transpileTypeScript(source: string, moduleName: string, config?: any): string;
            /**
                * Transpiles the given TS source to JS source
                * @param source the source to transpile
                */
            static TranspileTypeScript(source: string, moduleName: string, config?: any): Promise<string>;
            /**
                * Gets all the typings and returns its result
                */
            static GetTypings(): Promise<Typings[]>;
            /**
                * Creates a windowed editor
                * @param options: the editor's configuration
                */
            static CreateWindowedEditor(options: {
                    name: string;
                    data: any;
                    baseData: any;
                    property: string;
                    baseEditor: CodeEditor;
            }): Promise<void>;
    }
}

declare module 'babylonjs-editor/editor/gui/form' {
    export interface FormField {
            name: string;
            type: 'text' | 'float' | 'int' | 'alphanumeric' | 'enum' | 'list' | string;
            required?: boolean;
            options?: {
                    items?: string[];
            };
            html?: {
                    caption?: string;
            };
    }
    export default class Form {
            element: W2UI.W2Form;
            name: string;
            fields: FormField[];
            onChange: () => void;
            /**
                * Constructor
                * @param name the name of the form
                */
            constructor(name: string);
            /**
                * Returns if the form is valid
                */
            isValid(): boolean;
            /**
                * Builds the form
                * @param parentId the parent id of the form
                */
            build(parentId: string): void;
    }
}

declare module 'babylonjs-editor/editor/gui/edition' {
    import { Color3, Color4, Vector2, Vector3, Vector4, BaseTexture, Scene } from 'babylonjs';
    import * as dat from 'dat-gui';
    import Editor from 'babylonjs-editor/editor/editor';
    export default class Edition {
            element: dat.GUI;
            /**
                * Constructor
                */
            constructor();
            /**
                * Adds a folder
                * @param name the folder name
                */
            addFolder(name: string): dat.GUI;
            /**
                * Add a gui controller
                * @param target the target object
                * @param propName the property of the object
                */
            add(target: any, propName: string, other?: string[]): dat.GUIController;
            /**
                * Removes the dat element
                */
            remove(): void;
            /**
                * Updates the display of all elements
                * @param folder: the root folder
                */
            updateDisplay(folder?: dat.GUI): void;
            /**
                * Call the given callback on each recursive onFinishChange
                * @param folder the root folder
                * @param callback the callback when a property changed
                */
            onFinishChange(folder: dat.GUI, callback: (property: string, result: any, object?: any, initialValue?: any) => void): void;
            /**
                * Call the given callback on each recursive onChange
                * @param folder the root folder
                * @param callback the callback when a property changed
                */
            onChange(folder: dat.GUI, callback: (property: string, result: any, object?: any, initialValue?: any) => void): void;
            /**
                * Returns a controller identified by its property name
                * @param property the property used by the controller
                * @param parent the parent folder
                */
            getController(property: string, parent?: dat.GUI): dat.GUIController;
            /**
                * Build the edition tool
                * @param parentId the parent id (dom element)
                */
            build(parentId: string): void;
            /**
                * Add a gui controller hexadecimal color
                * @param target the target object
                * @param propName the property of the object
                */
            addHexColor(target: any, propName: string): dat.GUIController;
            /**
                * Adds a color element
                * @param parent the parent folder
                * @param name the name of the folder
                * @param color the color reference
                * @param callback called on the user changes the color
                */
            addColor(parent: dat.GUI, name: string, color: Color3 | Color4, callback?: () => void): dat.GUI;
            /**
                * Adds a position element
                * @param parent the parent folder
                * @param name the name of the folder
                * @param vector the vector reference
                */
            addVector(parent: dat.GUI, name: string, vector: Vector2 | Vector3 | Vector4, callback?: () => void): dat.GUI;
            /**
                * Adds a texture controller
                * @param parent the parent folder
                * @param editor the editor reference
                * @param property the property of the object
                * @param object the object which has a texture
                * @param allowCubes if the cube textures should be displayed in the list
                * @param onlyCubes if only cube textures should be displayed in the list
                * @param callback: called when changed texture
                */
            addTexture(parent: dat.GUI, editor: Editor, scene: Scene, property: string, object: any, allowCubes?: boolean, onlyCubes?: boolean, callback?: (texture: BaseTexture) => void): dat.GUIController;
    }
}

declare module 'babylonjs-editor/editor/gui/tree' {
    import 'jstree';
    export type TreeNodeType = 'default' | 'bold' | 'italic' | 'boldItalic' | string;
    export interface TreeNode {
            id: string;
            text: string;
            img?: string;
            data?: any;
            parent?: string;
            children?: string[];
            type?: TreeNodeType;
            onExpand?: () => void;
            state?: {
                    checked?: boolean;
            };
    }
    export interface TreeContextMenuItem {
            id: string;
            text: string;
            multiple?: boolean;
            callback: (node: TreeNode) => void | Promise<void>;
            separatorBefore?: boolean;
            separatorAfter?: boolean;
            img?: string;
    }
    export default class Tree {
            name: string;
            wholerow: boolean;
            keyboard: boolean;
            multipleSelection: boolean;
            element: JSTree;
            onClick: <T>(id: string, data: T) => void;
            onDblClick: <T>(id: string, data: T) => void;
            onRename: <T>(id: string, name: string, data: T) => boolean;
            onContextMenu: <T>(id: string, data: T) => TreeContextMenuItem[];
            onMenuClick: <T>(id: string, node: TreeNode) => void;
            onCanDrag: <T>(id: string, data: T) => boolean;
            onDrag: <T, U>(node: T, parent: U) => boolean;
            onCopy: <T>(source: TreeNode, target: TreeNode, parent: T) => T;
            protected currentSelectedNode: string;
            protected moving: boolean;
            protected renaming: boolean;
            protected selecting: boolean;
            protected isFocused: boolean;
            static Instances: Tree[];
            /**
                * Returns if at least one code editor is focused
                */
            static HasOneFocused(): boolean;
            /**
                * Constructor
                * @param name the tree name
                */
            constructor(name: string);
            /**
                * Clear the tree
                * @param root: the root node from where to remove children. If undefined, root is taken
                */
            clear(root?: string): void;
            /**
                * Adds the given node to the tree
                * @param node: the node to add into the tree
                * @param parent: the optional parent of the node
                */
            add(node: TreeNode, parent?: string): TreeNode;
            /**
                * Deletes the given node
                * @param id the id of the node
                */
            remove(id: string): void;
            /**
                * Selects the given node
                * @param id the id of the node to select
                */
            select(id: string): void;
            /**
                * Sets the given type to the given node
                * @param id the id of the node to modify its type
                * @param type the type to set on node
                */
            setType(id: string, type?: TreeNodeType): void;
            /**
                * Returns the type of the given node
                * @param id the id of the node to retrieve its type
                */
            getType(id: string): any;
            /**
                * Returns the selected node
                */
            getSelected(): TreeNode;
            /**
                * Returns all the selected nodes
                */
            getAllSelected(): TreeNode[];
            /**
                * Get the given node
                * @param id the id of the node to get
                */
            get(id: string): TreeNode;
            /**
                * Renames the given node
                * @param id the node's id
                * @param name the new name of the node
                */
            rename(id: string, name: string): void;
            /**
                * Expands the given node
                * @param id the id of the node to expand
                */
            expand(id: string): void;
            /**
                * Returns nodes count currently drawn
                */
            getNodesCount(): number;
            /**
                * Set parent of the given node (id)
                * @param id the id of the node
                * @param parentId the parent id
                */
            setParent(id: string, parentId: string): void;
            /**
                * Marks the given node
                * @param id the id of the node to mark
                * @param marked if the node should be marked or not
                */
            markNode(id: string, marked: boolean): void;
            /**
                * Search nodes fitting the given value
                * @param value the value to search
                */
            search(value: string): void;
            /**
                * Destroys the tree
                */
            destroy(): void;
            /**
                * Builds the tree
                * @param parentId the parent id
                */
            build(parentId: string): void;
    }
}

declare module 'babylonjs-editor/editor/gui/dialog' {
    export default class Dialog {
            /**
                * Creates a GUI dialog window
                * @param title the title of the window
                * @param body the body of the window
                * @param callback the dialog's callback
                * @param yes callback when user clicks "yes"
                * @param no callback when the user clicks "no"
                */
            static Create(title: string, body: string, callback?: (result: string) => void, yes?: () => void, no?: () => void): Promise<string>;
            /**
                * Creates a GUI dialog with a text input
                * @param title the title of the dialog
                */
            static CreateWithTextInput(title: string): Promise<string>;
    }
}

declare module 'babylonjs-editor/editor/gui/context-menu' {
    import { IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    export interface ContextMenuItem {
            name: string;
            callback?: (itemId?: string) => void;
    }
    export default class ContextMenu {
            static Items: IStringDictionary<ContextMenuItem>;
            static OnItemClicked: (itemId?: string) => void;
            /**
                * Inits the context menu
                */
            static Init(): Promise<void>;
            /**
                * Configures the given element .oncontextmenu event
                * @param element the element to configure
                * @param items the items to draw once
                */
            static ConfigureElement(element: HTMLElement, items: IStringDictionary<ContextMenuItem>, callback?: (event: MouseEvent) => void): void;
            /**
                * Shows the context menu
                * @param mouseEvent the mouse event that fires the context menu
                * @param items the items to show on the user wants to show the context menu
                */
            static Show(mouseEvent: MouseEvent, items?: IStringDictionary<ContextMenuItem>): void;
    }
}

declare module 'babylonjs-editor/editor/gui/resizable-layout' {
    import * as GoldenLayout from 'golden-layout';
    import { IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    export type ComponentConfig = GoldenLayout.ComponentConfig & {
            html?: HTMLElement | string | (() => HTMLElement);
            onClose?: () => void;
            onClick?: () => void;
    };
    export type ItemConfigType = GoldenLayout.ItemConfig | ComponentConfig;
    export default class ResizableLayout {
            element: GoldenLayout;
            name: string;
            panels: ItemConfigType[];
            showCloseIcon: boolean;
            onPanelResize: () => void;
            protected containers: IStringDictionary<GoldenLayout.Container>;
            protected configs: IStringDictionary<ComponentConfig>;
            /**
                * Constructor
                * @param name the resizable layout name
                */
            constructor(name: string);
            /**
                * Returns the size of the given panel
                * @param type: the component name
                */
            getPanelSize(name: string): {
                    width: number;
                    height: number;
            };
            /**
                * Sets the given panel size
                * @param name the panel's name
                * @param value the new size of the panel
                */
            setPanelSize(name: string, value: number): void;
            /**
                * Shows the given tab
                * @param name the tab to show
                */
            showPanelTab(name: string): void;
            /**
                * Removes the given panel
                * @param name the name of the panel to remove
                */
            removePanel(name: string): void;
            /**
                * Adds a panel to the layout
                * @param stackId: the stack to add component in
                * @param config: the panel's configuration
                */
            addPanelToStack(stackId: string, config: ComponentConfig): void;
            /**
                * Returns the tabs count in the given stack id
                * @param stackId the stack id containing tabs
                */
            getTabsCount(stackId: string): number;
            /**
                * Builds the resizable layout
                * @param parentId the parent id
                */
            build(parentId: string): Promise<void>;
    }
}

declare module 'babylonjs-editor/editor/edition-tools/edition-tool' {
    import Edition from 'babylonjs-editor/editor/gui/edition';
    import Editor from 'babylonjs-editor/editor/editor';
    import { IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    export interface IEditionTool<T> {
            editor?: Editor;
            divId: string;
            tabName: string;
            object: T;
            tool: Edition;
            state: IStringDictionary<ToolState>;
            update(object: T): void;
            clear(): void;
            isSupported(object: any): boolean;
            onModified?(): void;
    }
    export interface ToolState {
            closed: boolean;
            children: IStringDictionary<ToolState>;
    }
    export default abstract class AbstractEditionTool<T> implements IEditionTool<T> {
            editor: Editor;
            object: T;
            tool: Edition;
            state: IStringDictionary<ToolState>;
            abstract divId: string;
            abstract tabName: string;
            /**
                * Constructor
                */
            constructor();
            /**
                * Updates the edition tool
                * @param object: the object to edit
                */
            update(object: T): void;
            /**
                * Called once the user selects a new object in
                * the scene of the graph
                */
            clear(): void;
            /**
                * Sets the name of the tool's tab
                * @param name the new name of the tab
                */
            protected setTabName(name: string): void;
            /**
                * Returns if the object is supported by the edition tool
                * @param object: the object to test
                */
            abstract isSupported(object: any): boolean;
    }
}

declare module 'babylonjs-editor/editor/typings/typings' {
    export interface IStringDictionary<T> {
        [index: string]: T;
    }
    export interface INumberDictionary<T> {
        [index: number]: T;
    }
    export interface IDisposable {
        dispose(): void;
    }
}

declare module 'babylonjs-editor/editor/typings/plugin' {
    import Editor from 'babylonjs-editor/editor/editor';
    import Layout from 'babylonjs-editor/editor/gui/layout';
    /**
        * Interface representing an editor plugin
        */
    export interface IEditorPlugin {
            /**
                * The div element being available to add custom HTML elements in it
                * By default width 100% and height: 100%
                */
            divElement: HTMLDivElement;
            /**
                * The name of the extension
                */
            name: string;
            /**
                * Called once creating the plugin
                */
            create(): Promise<void>;
            /**
                * Called once closing the plugin
                */
            close(): Promise<void>;
            /**
                * Called on the window, layout etc. is resized.
                */
            onResize?(): Promise<void> | void;
            /**
                * Called on the user hides the extension (by changing tab, etc.)
                */
            onHide?(): Promise<void> | void;
            /**
                * Called on the user shows the extension (by focising the tab, etc.)
                */
            onShow?(...params: any[]): Promise<void>;
            /**
                * On the editor asks to reload the extension, this function is called before
                * reloading definitely the extension
                */
            onReload?(): Promise<void>;
    }
    /**
        * Represents an exported editor plugin
        */
    export type EditorPluginConstructor = {
            default: new (editor: Editor, ...params: any[]) => IEditorPlugin;
    };
    /**
        * Abstract class representing an editor plugin
        */
    export abstract class EditorPlugin implements IEditorPlugin {
            /**
                * The editor reference
                */
            editor: Editor;
            /**
                * The div element being available to add custom HTML elements in it
                * By default width 100% and height: 100%
                */
            divElement: HTMLDivElement;
            /**
                * The name of the extension
                */
            name: string;
            /**
                * Constructor
                * @param name: the plugin's name
                */
            constructor(name: string);
            /**
                * Called once closing the plugin
                */
            abstract create(): Promise<void>;
            /**
                * Called once closing the plugin
                */
            close(): Promise<void>;
            /**
                * Gets wether or not the plugin has been closed
                */
            readonly closed: boolean;
            /**
                * Resizes the current layout giving tabs to draw and hide
                * @param layout the layout to resize
                * @param keep the panels to keep
                * @param hide the panels to hide
                */
            protected resizeLayout(layout: Layout, keep: string[], hide: string[]): void;
            /**
                * On load the extension for the first time
                */
            static OnLoaded(editor: Editor): void;
            static _Loaded: boolean;
    }
}

declare module 'babylonjs-editor/editor/typings/project' {
    import { Vector2, Vector3, Quaternion, Color3, Scene, Material, RenderTargetTexture, ReflectionProbe } from 'babylonjs';
    import { IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    import { AssetElement } from 'babylonjs-editor/extensions/typings/asset';
    /**
     * Animations
     */
    export interface AnimationEventValue {
            property?: string;
            value?: number | boolean | Vector2 | Vector3 | Color3 | Quaternion;
    }
    export interface AnimationEvent {
            type: string;
            target: Node | Scene;
            value: AnimationEventValue;
    }
    export interface AnimationEventFrame {
            frame: number;
            events: AnimationEvent[];
    }
    export interface Animation {
            targetName: string;
            targetType: string;
            serializationObject: any;
            events: AnimationEventFrame[];
    }
    export interface GlobalConfiguration {
            serializedCamera?: any;
            environmentTexture?: any;
            imageProcessingConfiguration?: any;
            ambientColor?: number[];
            clearColor?: number[];
            fog?: {
                    enabled: boolean;
                    start: number;
                    end: number;
                    density: number;
                    mode: number;
                    color: number[];
            };
    }
    /**
     * Custom Materials (sky, gradient, water, etc.)
     */
    export interface ProjectMaterial {
            serializedValues: any;
            meshesNames?: string[];
            newInstance?: boolean;
            _babylonMaterial?: Material;
    }
    /**
        * Custom textures (added by the editor or modified)
        */
    export interface ProjectTexture {
            serializedValues: any;
            newInstance: boolean;
    }
    /**
        * Custom physics impostors
        */
    export interface PhysicsImpostor {
            physicsMass: number;
            physicsFriction: number;
            physicsRestitution: number;
            physicsImpostor: number;
    }
    export interface Skeleton {
            serializationObject: any;
    }
    /**
        * Modified nodes in the editor (custom animations, for custom materials, etc.)
        */
    export interface Node {
            name: string;
            id: string;
            type: string;
            animations: Animation[];
            actions?: any;
            physics?: PhysicsImpostor;
            skeleton?: Skeleton;
            added?: boolean;
            serializationObject?: any;
    }
    /**
     * Custom particle systems
     */
    export interface ParticleSystem {
            hasEmitter: boolean;
            serializationObject: any;
            emitterPosition?: number[];
    }
    /**
     * Lens Flares
     */
    export interface LensFlare {
            serializationObject: any;
    }
    /**
     * Render targets
     */
    export interface RenderTarget {
            isProbe: boolean;
            serializationObject: any;
            waitingTexture?: RenderTargetTexture | ReflectionProbe;
    }
    /**
     * Sounds
     */
    export interface Sound {
            name: string;
            serializationObject: any;
    }
    export interface EffectLayer {
            name: string;
            serializationObject: any;
    }
    /**
     * Root object of project
     */
    export interface ProjectRoot {
            globalConfiguration: GlobalConfiguration;
            materials: ProjectMaterial[];
            textures: ProjectTexture[];
            particleSystems: ParticleSystem[];
            nodes: Node[];
            shadowGenerators: any[];
            lensFlares: LensFlare[];
            renderTargets: RenderTarget[];
            sounds: Sound[];
            actions: any;
            physicsEnabled: boolean;
            effectLayers: EffectLayer[];
            environmentHelper: any;
            requestedMaterials?: string[];
            customMetadatas?: IStringDictionary<any>;
            gui: any[];
            assets: IStringDictionary<AssetElement<any>[]>;
            removedObjects?: IStringDictionary<any>;
            filesList?: string[];
            editionToolsStates?: {
                    id: string;
                    state: any;
            }[];
    }
}

declare module 'babylonjs-editor/editor/project/project-code-editor' {
    import Editor from 'babylonjs-editor/editor/editor';
    import CodeProjectEditor, { Script } from 'babylonjs-editor-code-editor';
    /**
        * Options of the project code editor
        */
    export interface Options {
            /**
                * The name of the window
                */
            name: string;
            /**
                * The scripts to edit
                */
            scripts: Script[];
            /**
                * Once the editor is opened
                */
            onOpened?: () => void;
            /**
                * Once the user closed the code project editor
                */
            onClose?: () => void;
    }
    export default class CodeProjectEditorFactory {
            static Instances: {
                    instance: CodeProjectEditor;
                    popup: Window;
            }[];
            /**
                * Creates a new project code editor
                * @param editor the editor reference
                * @param options the options of the project code editor
                */
            static Create(editor: Editor, options: Options): Promise<CodeProjectEditor>;
            /**
                * Closes all the code project editors
                */
            static CloseAll(): void;
    }
}

declare module 'babylonjs-editor/editor/scene/scene-manager' {
    import { Scene, ActionManager, StandardRenderingPipeline, SSAORenderingPipeline, SSAO2RenderingPipeline, DefaultRenderingPipeline, IAnimatable, GlowLayer, HighlightLayer, EnvironmentHelper, Node, Sound } from 'babylonjs';
    import Editor from 'babylonjs-editor/editor/editor';
    import { IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    import PostProcessesExtension from 'babylonjs-editor/extensions/post-process/post-processes';
    export interface RemovedObject {
            reference?: Node | Sound;
            type?: string;
            name: string;
            serializationObject: any;
    }
    export default class SceneManager {
            static ActionManagers: IStringDictionary<ActionManager>;
            static StandardRenderingPipeline: StandardRenderingPipeline;
            static DefaultRenderingPipeline: DefaultRenderingPipeline;
            static SSAORenderingPipeline: SSAORenderingPipeline;
            static SSAO2RenderingPipeline: SSAO2RenderingPipeline;
            static GlowLayer: GlowLayer;
            static HighLightLayer: HighlightLayer;
            static EnvironmentHelper: EnvironmentHelper;
            static PostProcessExtension: PostProcessesExtension;
            static RemovedObjects: IStringDictionary<RemovedObject>;
            /**
                * Clears the scene manager
                */
            static Clear(): void;
            /**
                * Toggles all interaction events to disable but keep
                * references like Action Manager references etc.
                * @param scene the scene to toggle
                */
            static Toggle(scene: Scene): void;
            /**
                * Saves the original objects coming from the scene
                * @param scene the scene containing the original objects
                */
            static SaveOriginalObjects(scene: Scene): void;
            /**
                * Returns the animatable objects
                * @param scene the scene containing animatables
                */
            static GetAnimatables(scene: Scene): IAnimatable[];
            /**
                * Returns the animation frame bounds (min frame, max frame)
                * @param animatables the animtables to check
                */
            static GetAnimationFrameBounds(animatables: IAnimatable[]): {
                    min: number;
                    max: number;
            };
            /**
                * Plays all the animtables
                * @param scene: the scene containing the animatables
                * @param animatables the animatables to play
                */
            static PlayAllAnimatables(scene: Scene, animatables: IAnimatable[]): void;
            /**
                * Stops all the animatables
                * @param scene the scene containing the animatables
                * @param animatables the animatable objects
                */
            static StopAllAnimatables(scene: Scene, animatables: IAnimatable[]): void;
            /**
                * Clears all the unused materials from the scene
                * @param scene: the scene containing the materials
                */
            static CleanUnusedMaterials(scene: Scene): number;
            /**
                * Clears all the unused textures from the scene
                * @param scene the scene containing the textures
                */
            static CleanUnusedTextures(scene: Scene): number;
            /**
                * Saves the removed objects references
                * @param scene the scene containing the objects to remove
                * @param removedObjects the removed objects references
                */
            static ApplyRemovedObjects(scene: Scene, removedObjects: IStringDictionary<any>): void;
            /**
                * Draws a dialog to restore removed objects
                * @param editor the editor reference
                */
            static RestoreRemovedObjects(editor: Editor): void;
    }
}

declare module 'babylonjs-editor/editor/scene/scene-factory' {
    import { Mesh, ParticleSystem, GroundMesh, Light, EnvironmentHelper } from 'babylonjs';
    import { AdvancedDynamicTexture, Image } from 'babylonjs-gui';
    import { WaterMaterial } from 'babylonjs-materials';
    import Editor from 'babylonjs-editor/editor/editor';
    export default class SceneFactory {
            /**
                * Adds the given node to the scene's graph (on the right)
                * @param editor the editor reference
                * @param node the node to add
                */
            static AddToGraph(editor: Editor, node: any): void;
            /**
                * Creates a new default environment
                * @param editor the editor reference
                */
            static CreateDefaultEnvironment(editor: Editor): EnvironmentHelper;
            /**
                * Creates a new default particle system
                * @param editor: the editor reference
                * @param emitter: the emitter of the system
                */
            static CreateDefaultParticleSystem(editor: Editor, spriteSheetEnabled: boolean, emitter?: any): ParticleSystem;
            /**
                * Creates a skybox with a sky effect on it (SkyMaterial)
                * @param editor the editor reference
                */
            static CreateSkyEffect(editor: Editor): Mesh;
            /**
                * Creates a new mesh (if createGround set to true) with a water material assigned
                * the water will reflect all the scene's meshes
                * @param editor the editor reference
                */
            static CreateWaterEffect(editor: Editor, createGround?: boolean): WaterMaterial;
            /**
                * Creates a new dummy node (transform node)
                * @param editor the editor reference
                */
            static CreateDummyNode(editor: Editor): Mesh;
            /**
                * Creates a new ground mesh
                * @param editor: the editor reference
                */
            static CreateGroundMesh(editor: Editor): GroundMesh;
            /**
                * Creates a new cube mesh
                * @param editor: the editor reference
                */
            static CreateCube(editor: Editor): Mesh;
            /**
                * Creates a new sphere mesh
                * @param editor: the editor reference
                */
            static CreateSphere(editor: Editor): Mesh;
            /**
                * Creates a new plane mesh
                * @param editor: the editor reference
                */
            static CreatePlane(editor: Editor): Mesh;
            /**
                * Creates a new light
                * @param editor: the editor reference
                * @param type: the light type
                */
            static CreateLight(editor: Editor, type: 'point' | 'directional' | 'spot' | 'hemispheric'): Light;
            /**
                * Adds a new sound
                * @param editor: the editor reference
                */
            static AddSound(editor: Editor): void;
            /**
                * Creates a new GUI advanced texture
                * @param editor: the editor reference
                */
            static AddGui(editor: Editor): AdvancedDynamicTexture;
            /**
                * Creates a new GUI Image
                * @param editor: the editor reference
                */
            static AddGuiImage(editor: Editor): Image;
    }
}

declare module 'babylonjs-editor/editor/scene/scene-preview' {
    import Editor from 'babylonjs-editor/editor/editor';
    export default class ScenePreview {
            static externSocket: SocketIOClient.Socket;
            static localSocket: SocketIOClient.Socket;
            /**
                * Creates a scene preview listener
                */
            static Create(editor: Editor): Promise<void>;
            /**
                * Creates the files
                */
            static CreateFiles(editor: Editor, socket: SocketIOClient.Socket): Promise<void>;
    }
}

declare module 'babylonjs-editor/editor/scene/scene-picker' {
    import { Engine, Scene, AbstractMesh, PositionGizmo, RotationGizmo, ScaleGizmo, UtilityLayerRenderer, Observer, PointerInfo, Vector3, Camera, BoundingBoxGizmo } from 'babylonjs';
    import Editor from 'babylonjs-editor/editor/editor';
    import Toolbar from 'babylonjs-editor/editor/gui/toolbar';
    export enum GizmoType {
            NONE = 0,
            BOUNDING_BOX = 1,
            POSITION = 2,
            ROTATION = 3,
            SCALING = 4
    }
    export default class ScenePicker {
            editor: Editor;
            scene: Scene;
            canvas: HTMLCanvasElement;
            gizmosLayer: UtilityLayerRenderer;
            onPickedMesh: (mesh: AbstractMesh) => void;
            onUpdateMesh: (mesh: AbstractMesh) => void;
            currentMesh: AbstractMesh;
            protected lastMesh: AbstractMesh;
            protected lastClickedMesh: AbstractMesh;
            protected lastX: number;
            protected lastY: number;
            protected onCanvasPointer: Observer<PointerInfo>;
            protected onCanvasBlur: Observer<PointerEvent>;
            protected onCanvasFocus: Observer<Engine>;
            protected boundingBoxGizmo: BoundingBoxGizmo;
            protected positionGizmo: PositionGizmo;
            protected rotationGizmo: RotationGizmo;
            protected scalingGizmo: ScaleGizmo;
            protected currentGizmo: BoundingBoxGizmo | PositionGizmo | RotationGizmo | ScaleGizmo;
            /**
                * Constructor
                * @param editor: the editor reference
                * @param canvas: the canvas to track
                */
            constructor(editor: Editor, scene: Scene, canvas: HTMLCanvasElement);
            /**
                * Configures the given mesh
                * @param mesh the mesh to configure
                */
            configureMesh(mesh: AbstractMesh): void;
            /**
             * Sets if the scene picker is enabled
             */
            enabled: boolean;
            /**
                * Sets the gizmo type
                */
            gizmoType: GizmoType;
            /**
                * Sets the attached mesh for position, rotaiton and scaling gizmos
                * @param mesh the mesh to attach
                */
            setGizmoAttachedMesh(mesh: AbstractMesh): void;
            /**
                * Adds the events to the canvas
                */
            addEvents(): void;
            /**
                * Removes the scene picker events from the canvas
                */
            remove(): void;
            /**
                * Creates a default gizmos toolbar
                * @param divId the div id which will contains to toolbar
                */
            createGizmosToolbar(divId: string): Toolbar;
            /**
                * Adds undo redo
                * @param delta the delta value (from / to)
                * @param axis the moved axis
                */
            protected undoRedo(axis: 'x' | 'y' | 'z' | 'boundingbox'): void;
            /**
                * Called when canvas mouse is down
                * @param ev the mouse event
                */
            onCanvasDown(ev: MouseEvent): void;
            /**
                * Called when canvas mouse is up
                * @param ev the mouse event
                */
            onCanvasClick(ev: MouseEvent): void;
            /**
                * Called when mouse moves on canvas
                * @param ev the mouse event
                */
            onCanvasMove(ev: MouseEvent): void;
            /**
                * Called when double click on the canvas
                * @param ev: the mouse event
                */
            onCanvasDblClick(ev: MouseEvent): void;
            /**
                * Creates an starts an animation that targets the given "end" position
                * @param start the start target position
                * @param end the end target position
                * @param camera the camera to animate
                */
            static CreateAndPlayFocusAnimation(start: Vector3, end: Vector3, camera: Camera): void;
    }
}

declare module 'babylonjs-editor/editor/prefabs/asset-component' {
    import { Node, AbstractMesh, PickingInfo, Engine } from 'babylonjs';
    import Editor from 'babylonjs-editor/editor/editor';
    import { IAssetComponent, AssetElement, AssetContextMenu } from 'babylonjs-editor/extensions/typings/asset';
    import { Prefab, PrefabNodeType } from 'babylonjs-editor/editor/prefabs/prefab';
    export default class PrefabAssetComponent implements IAssetComponent {
            editor: Editor;
            id: string;
            assetsCaption: string;
            size: number;
            datas: AssetElement<Prefab>[];
            previewCanvas: HTMLCanvasElement;
            previewEngine: Engine;
            /**
                * Constructor
                * @param editor the editor reference
                */
            constructor(editor: Editor);
            /**
                * Creates a new prefab
                * @param sourceMesh the source mesh for the new prefab asset. Can be a single mesh or a root mesh
                */
            createPrefab(sourceNode: Node): Promise<AssetElement<Prefab>>;
            /**
                * Returns the asset containing the given node instance reference
                * @param node the node reference stored into the prefab instances
                */
            getAssetFromNode(node: PrefabNodeType): AssetElement<Prefab>;
            /**
                * On the user adds a new prefab asset
                * @param asset the asset to add in the collection
                */
            onAddAsset(asset: AssetElement<Prefab>): void;
            /**
                * On the user removes a prefab from his library
                * @param asset the asset to remove
                */
            onRemoveAsset(asset: AssetElement<Prefab>): void;
            /**
                * On the user double clicks on asset
                * @param asset the asset being double-clicked by the user
                */
            onDoubleClickAsset(asset: AssetElement<any>): void;
            /**
                * On the user drops an asset in the scene
                * @param targetMesh the mesh under the pointer
                * @param asset the asset being dropped
                * @param pickInfo the pick info once the user dropped the asset
                */
            onDragAndDropAsset(targetMesh: AbstractMesh, asset: AssetElement<Prefab>, pickInfo: PickingInfo): void;
            /**
                * On the user saves the editor project
                */
            onSerializeAssets(): AssetElement<Prefab>[];
            /**
                * On the user loads the editor project
                * @param data the previously saved data
                */
            onParseAssets(data: AssetElement<Prefab>[]): void;
            /**
                * On the assets panel requires the assets stored in this
                * asset component
                */
            onGetAssets(): Promise<AssetElement<Prefab>[]>;
            /**
                * On the user wants to show the context menu on the asset
                */
            onContextMenu(): AssetContextMenu[];
            /**
                * Builds the instances of the given asset
                * @param data the asset's data
                */
            buildInstances(data: AssetElement<Prefab>[]): number;
            /**
                * Sets all the instances serializable or not
                * @param serializable if the instances are serializable
                */
            setSerializable(serializable: boolean): void;
    }
}

declare module 'babylonjs-editor/editor/prefabs/prefab' {
    import { InstancedMesh, SpotLight, PointLight, DirectionalLight, Mesh, ParticleSystem } from 'babylonjs';
    import { IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    export type PrefabNodeType = SpotLight | PointLight | DirectionalLight | InstancedMesh | ParticleSystem;
    export interface Prefab {
        isPrefab: boolean;
        nodes: string[];
        nodeIds: string[];
        instances: IStringDictionary<any[]>;
        sourceNodes?: (Mesh | PrefabNodeType)[];
        sourceNode?: Mesh | PrefabNodeType;
        sourceInstances?: IStringDictionary<PrefabNodeType[]>;
    }
}

declare module 'babylonjs-editor/editor/particles/asset-component' {
    import { AbstractMesh, PickingInfo } from 'babylonjs';
    import { IAssetComponent, AssetElement } from 'babylonjs-editor/extensions/typings/asset';
    import Editor from 'babylonjs-editor/editor/editor';
    export interface ParticlesCreatorMetadata {
            name: string;
            psData: any;
    }
    export default class ParticlesAssetComponent implements IAssetComponent {
            editor: Editor;
            id: string;
            assetsCaption: string;
            datas: AssetElement<ParticlesCreatorMetadata>[];
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(editor: Editor);
            /**
                * On the user renames the asset
                * @param asset the asset being renamed
                * @param name the new name of the asset
                */
            onRenameAsset(asset: AssetElement<ParticlesCreatorMetadata>, name: string): void;
            /**
                * On the user wants to remove the asset
                * @param asset the asset to remove
                */
            onRemoveAsset(asset: AssetElement<any>): void;
            /**
                * On the user adds an asset
                * @param asset the asset to add
                */
            onAddAsset(asset: AssetElement<any>): void;
            /**
                * Creates a new particle systems set asset
                */
            onCreateAsset(name: string): Promise<AssetElement<any>>;
            /**
                * On get all the assets to be drawn in the assets component
                */
            onGetAssets(): AssetElement<any>[];
            /**
                * On the user double clicks on asset
                * @param asset the asset being double-clicked by the user
                */
            onDoubleClickAsset(asset: AssetElement<any>): void;
            /**
                * On the user drops an asset in the scene
                * @param targetMesh the mesh under the pointer
                * @param asset the asset being dropped
                * @param pickInfo the pick info once the user dropped the asset
                */
            onDragAndDropAsset(targetMesh: AbstractMesh, asset: AssetElement<ParticlesCreatorMetadata>, pickInfo: PickingInfo): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerializeAssets(): AssetElement<ParticlesCreatorMetadata>[];
            /**
                * On the user loads the editor project
                * @param data the previously saved data
                */
            onParseAssets(data: AssetElement<ParticlesCreatorMetadata>[]): void;
    }
}

declare module 'babylonjs-editor/editor/storage/storage' {
    import Editor from 'babylonjs-editor/editor/editor';
    import Picker from 'babylonjs-editor/editor/gui/picker';
    export type FileType = string | Uint8Array | ArrayBuffer;
    export interface CreateFiles {
            name: string;
            data?: FileType | Promise<FileType>;
            file?: File;
            folder?: CreateFiles[];
            doNotOverride?: boolean;
    }
    export interface GetFiles {
            name: string;
            folder: any;
    }
    export default abstract class Storage {
            editor: Editor;
            picker: Picker;
            onCreateFiles: (folder: string) => void;
            protected filesCount: number;
            protected _uploadedCount: number;
            /**
                * Returns the appropriate storage (OneDrive, Electron, etc.)
                * @param editor the editor reference
                */
            static GetStorage(editor: Editor): Promise<Storage>;
            /**
                * Constructor
                * @param editor: the editor reference
                */
            constructor(editor: Editor);
            /**
                * Opens the folder picker
                * @param title the title of the picker
                * @param filesToWrite the array of files to write on the HDD
                * @param folder the current working directory to browse
                * @param overrideFilename if the file browser should override the filename
                */
            openPicker(title: string, filesToWrite: CreateFiles[], folder?: string, overrideFilename?: boolean): Promise<any>;
            /**
                * Uploads the files
                * @param folder the target folder
                * @param filesToWrite the files to upload
                */
            protected uploadFiles(folder: string, filesToWrite: CreateFiles[]): Promise<void>;
            /**
                * Recursively creates the given files (uncluding folders)
                * @param folder: the parent folder of the files
                * @param files files to create
                */
            protected recursivelyCreateFiles(folder: any, files: CreateFiles[]): Promise<void>;
            /**
                * Returns the number of files to upload
                * @param files the files to count
                */
            protected recursivelyGetFilesToUploadCount(files: CreateFiles[]): number;
            /**
             * Returns the number of uploaded files
             */
            protected uploadedCount: number;
            /**
                * Creates the given folders
                * @param folder the parent folder
                * @param names the folders names
                */
            abstract createFolders(folder: any, names: string[]): Promise<void>;
            /**
                * Creates the given files
                * @param folder the parent folder
                * @param files the files to write
                */
            abstract createFiles(folder: any, files: CreateFiles[]): Promise<void>;
            /**
                * Returns the files available in the given folder
                * @param folder the parent folder
                */
            abstract getFiles(folder?: any): Promise<GetFiles[]>;
    }
}

declare module 'babylonjs-editor/editor/vscode/vscode-socket' {
    import Editor from 'babylonjs-editor/editor/editor';
    export default class VSCodeSocket {
            static Socket: SocketIOClient.Socket;
            static OnUpdateBehaviorCode: (s: any) => void;
            static OnUpdateMaterialCode: (s: any) => void;
            static OnUpdatePostProcessCode: (s: any) => void;
            static OnUpdateBehaviorGraph: (g: any) => void;
            /**
                * Creates a scene preview listener
                */
            static Create(editor: Editor): Promise<void>;
            /**
                * Refreshes the scripts
                * @param scripts the scripts to send (alone or as an array)
                */
            static Refresh(): void;
            /**
                * Refreshes the project
                */
            static RefreshProject(): Promise<void>;
            /**
                * Refrehses the given behavior (single or array)
                * @param data: the behavior datas to update (single or array)
                */
            static RefreshBehavior(data: any | any[]): void;
            /**
                * Refrehses the given materials (single or array)
                * @param data: the materials datas to update (single or array)
                */
            static RefreshMaterial(data: any | any[]): void;
            /**
                * Refreshes the given post-processes (single or array)
                * @param data: the post-processes datas to update (single or array)
                */
            static RefreshPostProcess(data: any | any[]): void;
            /**
                * Refreshes the given graphs (single or array)
                * @param data: the graphs datas to update (single or array)
                */
            static RefreshBehaviorGraph(data: any | any[]): void;
            /**
                * Refreshes the scene infos
                */
            static RefreshSceneInfos(): void;
            /**
                * Refreshes the selected object in the editor
                * @param object the object being selected in the editor
                */
            static RefreshSelectedObject(object: any): void;
    }
}

declare module 'babylonjs-editor/editor/core' {
    import { Engine, Scene, Observable } from 'babylonjs';
    import { AdvancedDynamicTexture } from 'babylonjs-gui';
    import { ProjectRoot } from 'babylonjs-editor/editor/typings/project';
    export interface IUpdatable {
            /**
                * On before render the scene
                */
            onPreUpdate?(): void;
            /**
                * On after render the scene
                */
            onPostUpdate?(): void;
    }
    export default class Core {
            engine: Engine;
            scenes: Scene[];
            scene: Scene;
            uiTextures: AdvancedDynamicTexture[];
            currentSelectedObject: any;
            disableObjectSelection: boolean;
            updates: IUpdatable[];
            onSelectObject: Observable<any>;
            onSelectAsset: Observable<any>;
            onResize: Observable<{}>;
            onAddObject: Observable<{}>;
            onRemoveObject: Observable<{}>;
            onModifyingObject: Observable<{}>;
            onModifiedObject: Observable<{}>;
            onDropFiles: Observable<{
                    target: HTMLElement;
                    files: FileList;
            }>;
            onSceneLoaded: Observable<{
                    scene: Scene;
                    file: File;
                    project?: ProjectRoot;
            }>;
            renderScenes: boolean;
            /**
                * Constructor
                */
            constructor();
            /**
                * Removes the given scene from the registered scenes
                * @param scene: the scene reference to remove
                */
            removeScene(scene: Scene, dispose?: boolean): boolean;
            /**
                * Removes the given UI (advanced texture) from the registered UIS
                * @param ui: the ui advanced texture reference to remove
                */
            removeUI(ui: AdvancedDynamicTexture, dispose?: boolean): boolean;
            /**
                * Updates the rendering + notify updaters
                */
            update(): void;
    }
}

declare module 'babylonjs-editor/editor/components/toolbar' {
    import Editor from 'babylonjs-editor/editor/editor';
    import { IEditorPlugin } from 'babylonjs-editor/editor/typings/plugin';
    import Toolbar from 'babylonjs-editor/editor/gui/toolbar';
    export default class EditorToolbar {
            protected editor: Editor;
            main: Toolbar;
            tools: Toolbar;
            /**
                * Constructor
                * @param editor: the editor's reference
                */
            constructor(editor: Editor);
            /**
                * Notifies the user that something happens
                * @param message message to draw
                */
            notifyRightMessage(message: string): void;
            /**
                * Once the user clicks on a menu of the main toolbar
                * @param target the target element
                */
            protected onMainClick(target: string): Promise<void>;
            /**
                * Once the user clicks on a menu of the tools toolbar
                * @param target the target element
                */
            protected onToolsClick(target: string): void;
            /**
                * Loads an editor tool and add it in the edit-panel
                * @param url the URL of the tool
                * @param name: the name of the tool to draw when locking the panel
                */
            protected loadTool(url: string, name: string): Promise<IEditorPlugin>;
    }
}

declare module 'babylonjs-editor/editor/components/graph' {
    import { Scene, Node } from 'babylonjs';
    import Editor from 'babylonjs-editor/editor/editor';
    import Tree, { TreeNode } from 'babylonjs-editor/editor/gui/tree';
    export default class EditorGraph {
            protected editor: Editor;
            tree: Tree;
            root: string;
            gui: string;
            currentObject: any;
            /**
                * Constructor
                * @param editor the editor reference
                */
            constructor(editor: Editor);
            /**
             * Rename the node with id "id"
             * @param id the id of the node
             * @param name the new name/id
             */
            renameNode(id: string, name: string): void;
            /**
                * Set parent of the given node (id)
                * @param id the id of the node
                * @param parentId the parent id
                */
            setParent(id: string, parentId: string): void;
            /**
                * Adds a new node
                * @param node: the node to add
                * @param parentId: the parent id of the node to add
                */
            add(node: TreeNode, parentId: string): void;
            /**
                * Selects the given node id
                * @param id the node id
                */
            select(id: string): void;
            /**
                * Returns the selected node
                */
            getSelected(): TreeNode;
            /**
                * Returns all the selected nodes
                */
            getAllSelected(): TreeNode[];
            /**
                * Returns a anode
                * @param data: the data to search
                */
            getByData(data: any): TreeNode;
            /**
                * Clears the graph
                */
            clear(): void;
            /**
                * Fills the tree
                * @param scene: the root scene
                * @param root: the root node
                */
            fill(scene?: Scene, root?: Node): void;
            /**
                * Updates the mark of the given object in graph
                * @param obj the object to mark
                */
            updateObjectMark(obj: any): void;
            /**
                * Configures the graph
                */
            configure(): void;
            /**
             * Returns the icon related to the object type
             * @param object
             */
            getIcon(obj: any): string;
            /**
                * Fills the sounds giving the scene and the root node (attached mesh or scene)
                * @param scene: the scene containing the sound
                * @param root: the root node to check
                */
            protected fillSounds(scene: Scene, root: Scene | Node): number;
            /**
                * Fills the GUI advanced textures
                * @param root: the node to check GUI is attached to
                */
            protected fillGuiTextures(root: Node): number;
            /**
                * On the user clicks on a context menu item
                * @param id the context menu item id
                * @param node the related tree node
                */
            onMenuClick(id: string, node?: TreeNode): Promise<void>;
    }
}

declare module 'babylonjs-editor/editor/components/preview' {
    import Layout from 'babylonjs-editor/editor/gui/layout';
    import Toolbar from 'babylonjs-editor/editor/gui/toolbar';
    import Editor from 'babylonjs-editor/editor/editor';
    export default class EditorPreview {
            protected editor: Editor;
            layout: Layout;
            toolbar: Toolbar;
            /**
                * Constructor
                * @param editor: the editor reference
                */
            constructor(editor: Editor);
            /**
                * Resizes the preview
                */
            resize(): void;
            /**
                * Sets a click and the given item's id
                * @param id the id of the item to click
                */
            setToolClicked(id: string): void;
            /**
                * Resets the preview panel.
                */
            reset(): void;
            /**
                * On the user clicks on the toolbar
                * @param id the id of the clicked item
                */
            protected onToolbarClicked(id: string): void;
    }
}

declare module 'babylonjs-editor/editor/components/inspector' {
    /**
        * Edition tools
        */
    import { IEditionTool, ToolState } from 'babylonjs-editor/editor/edition-tools/edition-tool';
    /**
        * Editor
        */
    import Editor from 'babylonjs-editor/editor/editor';
    import { IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    export interface ToolsStates {
            id: string;
            state: IStringDictionary<ToolState>;
    }
    export default class EditorInspector {
            protected editor: Editor;
            tools: IEditionTool<any>[];
            currentTools: IEditionTool<any>[];
            root: string;
            tabs: W2UI.W2Tabs;
            currentObject: any;
            protected lastTabName: string;
            /**
                * Constructor
                * @param editor: the editor's reference
                */
            constructor(editor: Editor, rootDiv?: string);
            /**
                * Resizes the edition tools
                * @param width the width of the panel
                */
            resize(width: number): void;
            /**
                * Add the given tool (IEditionTool)
                * @param tool the tool to add
                */
            addTool(tool: IEditionTool<any>): void;
            /**
                * Sets the object to edit
                * @param object the object to edit
                */
            setObject(object: any): void;
            /**
                * Refresh the edition tool
                */
            refresh(): void;
            /**
                * Updates the display of all visible edition tools
                */
            updateDisplay(): void;
            /**
                * Returns the current tools configurations
                */
            getToolsStates(): ToolsStates[];
            /**
                * Sets the states of each tool
                * @param states the list of states for each tool
                */
            setToolsStates(states: ToolsStates[]): void;
            /**
                * Notifies that the object is being modified and got notified
                */
            notifyObjectChanged(): void;
            /**
                * When a tab changed
                * @param target the target tab Id
                */
            protected changeTab(target: string): void;
    }
}

declare module 'babylonjs-editor/editor/components/edit-panel' {
    import Editor from 'babylonjs-editor/editor/editor';
    import { IEditorPlugin } from 'babylonjs-editor/editor/typings/plugin';
    export default class EditorEditPanel {
            protected editor: Editor;
            static PluginCount: number;
            protected currentPlugin: IEditorPlugin;
            /**
                * Constructor
                * @param editor: the editor reference
                */
            constructor(editor: Editor);
            /**
                * Adds the given plugin to the
                * @param plugin the plugin to add
                */
            addPlugin(pluginUrl: string): void;
            /**
                * Shows the given plugin
                * @param plugin: the plugin to show
                * @param params: parameters to send to the plugin (onShow)
                */
            showPlugin(plugin: IEditorPlugin, ...params: any[]): Promise<void>;
    }
}

declare module 'babylonjs-editor/editor/components/stats' {
    import Editor from 'babylonjs-editor/editor/editor';
    import Layout from 'babylonjs-editor/editor/gui/layout';
    export default class Stats {
            editor: Editor;
            layout: Layout;
            renderingDiv: JQuery<HTMLDivElement>;
            averageFPS: JQuery<HTMLElement>;
            instantaneousFPS: JQuery<HTMLElement>;
            averageFrameTime: JQuery<HTMLElement>;
            sceneDiv: JQuery<HTMLDivElement>;
            texturesCount: JQuery<HTMLElement>;
            materialsCount: JQuery<HTMLElement>;
            compiledEffects: JQuery<HTMLElement>;
            frameInterval: number;
            /**
                * Constructor
                * @param editor the editor reference
                */
            constructor(editor: Editor);
            /**
                * Update the stats
                */
            updateStats(): void;
    }
}

declare module 'babylonjs-editor/editor/components/assets' {
    import Editor from 'babylonjs-editor/editor/editor';
    import { ContextMenuItem } from 'babylonjs-editor/editor/gui/context-menu';
    import Layout from 'babylonjs-editor/editor/gui/layout';
    import Toolbar from 'babylonjs-editor/editor/gui/toolbar';
    import { IAssetComponent, AssetElement } from 'babylonjs-editor/extensions/typings/asset';
    import PrefabAssetComponent from 'babylonjs-editor/editor/prefabs/asset-component';
    import ParticlesAssetComponent from 'babylonjs-editor/editor/particles/asset-component';
    import { IStringDictionary } from 'babylonjs-editor/editor/typings/typings';
    export interface AssetPreviewData {
            asset: AssetElement<any>;
            img: HTMLImageElement;
            title: HTMLElement;
            parent: HTMLDivElement;
    }
    export default class EditorAssets {
            protected editor: Editor;
            tabs: W2UI.W2Tabs;
            layout: Layout;
            toolbar: Toolbar;
            components: IAssetComponent[];
            prefabs: PrefabAssetComponent;
            particles: ParticlesAssetComponent;
            assetPreviewDatas: AssetPreviewData[];
            protected currentComponent: IAssetComponent;
            protected emptyTextNode: HTMLHeadElement;
            /**
                * Constructor
                * @param editor the editore reference
                */
            constructor(editor: Editor);
            /**
                * Clears the assets components
                */
            clear(): void;
            /**
                * Adds the default components
                */
            addDefaultComponents(): void;
            /**
                * Refreshes the tabs
                */
            refresh(id?: string): Promise<void>;
            /**
                * Adds a new tab to draw components
                * @param component the component to add in assets panel
                */
            addTab(component: IAssetComponent): void;
            /**
                * Shows the tab identified by the given id
                * @param id the id of the tab to show
                */
            showTab(id: string): void;
            /**
                * Returns the asset preview data from the given asset element
                * @param asset the source asset
                */
            getAssetPreviewData(asset: AssetElement<any>): AssetPreviewData;
            /**
                * Adds a new asset to the assets store
                * @param component the component used to add an asset
                */
            addAsset(component?: IAssetComponent): Promise<AssetElement<any>>;
            /**
                * Returns the drag end event function
                * @param component the source component
                * @param asset the dropped asset
                */
            protected dragEnd(component: IAssetComponent, asset: AssetElement<any>): (ev: DragEvent) => void;
            /**
                * On the user clicks on the toolbar
                * @param id the id of the clicked item
                */
            protected toolbarClicked(id: string): Promise<void>;
            /**
                * Hightlights the given image element
                * @param img the image element to highlight
                */
            protected highlight(img: HTMLImageElement): void;
            /**
                * Processes the context menu for the clicked item
                * @param ev the mouse event object
                * @param component the component being modified
                * @param asset the target asset
                */
            protected getContextMenuItems(component: IAssetComponent, asset: AssetElement<any>): IStringDictionary<ContextMenuItem>;
    }
}

declare module 'babylonjs-editor/editor/components/files' {
    import Editor from "babylonjs-editor/editor/editor";
    import Layout from "babylonjs-editor/editor/gui/layout";
    import Toolbar from "babylonjs-editor/editor/gui/toolbar";
    export default class EditorFiles {
            protected editor: Editor;
            tabs: W2UI.W2Tabs;
            layout: Layout;
            toolbar: Toolbar;
            protected divContent: HTMLDivElement;
            /**
                * Constructor
                * @param editor the editore reference
                */
            constructor(editor: Editor);
            /**
                * Shows the tab identified by the given id
                * @param id the id of the tab to show
                */
            showTab(id: string): void;
            /**
                * Refreshes the
                */
            refresh(): void;
            /**
                * Filers the files input store according to the given
                */
            protected filter(): File[];
            /**
                * Returns the given array filters according to the given extensions
                * @param files the files to filter
                * @param extensions the extensions to check
                */
            protected getFilteredArray(files: File[], extensions: string[]): File[];
            /**
                * Highlights the given item and removes highlihhting in other items
                * @param parent the item to highlight
                */
            protected highlightItem(parent: HTMLDivElement): void;
    }
}

declare module 'babylonjs-editor/editor/scene/scene-icons' {
    import { Scene, Mesh, Texture, StandardMaterial, Vector3, PickingInfo } from 'babylonjs';
    import Editor from 'babylonjs-editor/editor/editor';
    export default class SceneIcons {
            scene: Scene;
            cameraTexture: Texture;
            lightTexture: Texture;
            particleTexture: Texture;
            soundTexture: Texture;
            camerasPlanes: Mesh[];
            lightsPlanes: Mesh[];
            particleSystemsPlanes: Mesh[];
            soundsPlanes: Mesh[];
            camerasMaterial: StandardMaterial;
            lightsMaterial: StandardMaterial;
            particleSystemsMaterial: StandardMaterial;
            soundMaterial: StandardMaterial;
            protected editor: Editor;
            /**
                * Constructor
                * @param editor: the editor instance
                */
            constructor(editor: Editor);
            /**
                * On post update the scenes
                */
            onPostUpdate(): void;
            /**
                * Launch a ray to try to pick a mesh in the icons scene
                * @param offsetX the x position of the mouse
                * @param offsetY the y position of the mouse
                * @param getSourceObject if the pick result should set the picked mesh as the source plane mesh
                */
            pickIcon(offsetX: number, offsetY: number, getSourceObject?: boolean): PickingInfo;
            /**
                * Creates all the (count) planes and applies the given material
                * @param planes the array containing the existing planes
                * @param material the material to apply to the new planes
                * @param count number of planes to create
                */
            protected createPlanes(planes: Mesh[], material: StandardMaterial, count: number): void;
            /**
                * Configures the given plane according to the given source object position
                * @param plane: the plane to configure to draw in the helper's scene
                * @param sourcePosition: the position of the object to draw the helper in the scene
                */
            protected configurePlane(plane: Mesh, sourcePosition: Vector3): void;
            /**
                * Creates a new texture
                * @param url: the url of the texture
                */
            protected createTexture(url: string): Texture;
    }
}

declare module 'babylonjs-editor/extensions/typings/asset' {
    import { AbstractMesh, PickingInfo } from 'babylonjs';
    export interface AssetElement<T> {
        img?: string;
        name?: string;
        data?: T;
        separator?: string;
    }
    export interface AssetContextMenu {
        id: string;
        text: string;
        img?: string;
        callback?: (asset?: AssetElement<any>) => void;
    }
    export interface IAssetComponent {
        id?: string;
        assetsCaption?: string;
        size?: number;
        onCreateAsset?(name: string): AssetElement<any> | Promise<AssetElement<any>>;
        onRenameAsset?(asset: AssetElement<any>, name: string): void;
        onGetAssets?(): AssetElement<any>[] | Promise<AssetElement<any>[]>;
        onRemoveAsset?(asset: AssetElement<any>): void;
        onAddAsset?(asset: AssetElement<any>): void;
        onDragAndDropAsset?(targetMesh: AbstractMesh, asset: AssetElement<any>, pickInfo?: PickingInfo): void;
        onDoubleClickAsset?(asset: AssetElement<any>): void;
        onContextMenu?(): AssetContextMenu[];
        onSerializeAssets?(): AssetElement<any>[];
        onParseAssets?(data: AssetElement<any>[]): void;
    }
}

declare module 'babylonjs-editor/extensions/post-process/post-processes' {
    import { Scene, StandardRenderingPipeline, SSAO2RenderingPipeline, DefaultRenderingPipeline } from 'babylonjs';
    import Extension from 'babylonjs-editor/extensions/extension';
    export interface PostProcessMetadata {
            standard?: any;
            default?: any;
            ssao2?: any;
    }
    export default class PostProcessesExtension extends Extension<PostProcessMetadata> {
            standard: StandardRenderingPipeline;
            default: DefaultRenderingPipeline;
            ssao2: SSAO2RenderingPipeline;
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            onApply(data: PostProcessMetadata, rootUrl?: string): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): PostProcessMetadata;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: PostProcessMetadata): void;
    }
}

declare module 'babylonjs-editor/extensions/extension' {
    import { Scene } from 'babylonjs';
    import { IExtension } from 'babylonjs-editor/extensions/typings/extension';
    export default abstract class Extension<T> implements IExtension<T> {
            scene: Scene;
            datas: T;
            alwaysApply: boolean;
            /**
                * Constructor
                * @param scene: the scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            abstract onApply(data: T, rootUrl?: string): void;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            abstract onLoad(data: T): void;
            /**
                * Adds a script tag element to the dom including source URL
                * @param code: the code's text
                * @param url: the URL of the script to show in devtools
                */
            static AddScript(code: string, url: string): HTMLScriptElement;
    }
}

declare module 'babylonjs-editor/extensions/typings/extension' {
    import { Scene } from 'babylonjs';
    import { IAssetComponent } from 'babylonjs-editor/extensions/typings/asset';
    /**
        * Interface representing an editor extension
        */
    export interface IExtension<T> extends IAssetComponent {
            /**
                * Sets if the extensions is always applied
                */
            alwaysApply: boolean;
            /**
                * On apply the extension
                */
            onApply(data: T, rootUrl?: string): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize?(): T;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad?(data: T): void;
    }
    export type ExtensionConstructor<T> = new (scene: Scene) => IExtension<T>;
}

